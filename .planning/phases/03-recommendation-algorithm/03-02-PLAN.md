---
phase: 03-recommendation-algorithm
plan: 02
type: tdd
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/lib/recommend.ts
  - __tests__/recommend.test.ts
autonomous: true

must_haves:
  truths:
    - "A weekly plan of 5 restaurants is generated from a single function call with a budget input"
    - "Every generated plan costs no more than the specified weekly budget"
    - "No generated plan contains more than 2 consecutive restaurants of the same cuisine type"
    - "The algorithm terminates when the budget cannot be satisfied and returns a graceful fallback"
  artifacts:
    - path: "src/lib/recommend.ts"
      provides: "generateWeeklyPlan function and WeeklyPlan interface"
      exports: ["WeeklyPlan", "generateWeeklyPlan"]
    - path: "__tests__/recommend.test.ts"
      provides: "Unit tests for generateWeeklyPlan"
      contains: "describe.*generateWeeklyPlan"
  key_links:
    - from: "src/lib/recommend.ts"
      to: "src/lib/types.ts"
      via: "import type { Restaurant }"
      pattern: "import.*Restaurant.*from.*types"
    - from: "__tests__/recommend.test.ts"
      to: "src/lib/recommend.ts"
      via: "import { generateWeeklyPlan }"
      pattern: "import.*generateWeeklyPlan.*from.*recommend"
    - from: "__tests__/recommend.test.ts"
      to: "src/lib/restaurants.ts"
      via: "import { DEFAULT_RESTAURANTS }"
      pattern: "import.*DEFAULT_RESTAURANTS.*from.*restaurants"
---

<objective>
TDD the `generateWeeklyPlan` function: write failing tests first, then implement the slot-by-slot greedy algorithm to make them pass.

Purpose: This is the core algorithm of the app. TDD ensures budget enforcement, cuisine diversity, and graceful fallback are correct by design — not patched after the fact.
Output: Working, tested `generateWeeklyPlan` in `src/lib/recommend.ts` with comprehensive tests in `__tests__/recommend.test.ts`.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-recommendation-algorithm/03-RESEARCH.md

@src/lib/types.ts
@src/lib/restaurants.ts
@vitest.config.mts
</context>

<feature>
  <name>generateWeeklyPlan</name>
  <files>src/lib/recommend.ts, __tests__/recommend.test.ts</files>
  <behavior>
    generateWeeklyPlan(pool: Restaurant[], weeklyBudget: number) => WeeklyPlan

    WeeklyPlan = { days: Restaurant[] (length 5), totalCost: number, weeklyBudget: number }

    Constraints:
    - plan.days.length === 5 (always)
    - plan.totalCost <= weeklyBudget (when budget >= minimum satisfiable = 5 x cheapest)
    - No 3 consecutive days with same cuisine type
    - Never throws — returns graceful fallback on impossible budget

    Test cases (input -> expected):
    - (DEFAULT_RESTAURANTS, 750) -> 5 days, totalCost <= 750, no 3-consecutive cuisine
    - (DEFAULT_RESTAURANTS, 2000) -> 5 days, totalCost <= 2000 (generous, easy)
    - (DEFAULT_RESTAURANTS, 325) -> 5 days, totalCost <= 325 (minimum: 5 x 65)
    - (DEFAULT_RESTAURANTS, 50) -> 5 days, does NOT throw (impossible budget, graceful fallback)
    - (DEFAULT_RESTAURANTS, 100) -> 5 days, does NOT throw (budget < min, fallback)
    - (single-restaurant pool, 1000) -> 5 days, all same restaurant
    - (same-cuisine pool, 750) -> 5 days, no more than 2 consecutive (cuisine diversity still enforced even though impossible to fully satisfy)
    - ([], 750) -> throws Error (empty pool is the ONLY throw case)

    Statistical validation (run N=100 times):
    - Budget constraint holds every time for satisfiable budgets
    - Cuisine diversity holds every time
    - Different plans are generated (not deterministic)
  </behavior>
  <implementation>
    Slot-by-slot greedy algorithm (from research):

    1. Export `WeeklyPlan` interface: { days: Restaurant[], totalCost: number, weeklyBudget: number }
    2. Internal constant: MAX_RETRIES = 50 (not needed given the approach below, but cap the eligible filtering)
    3. Internal `hasCuisineViolation(plan, slotIndex, candidate)`: check if placing candidate at slotIndex creates 3-consecutive same cuisine by checking plan[slotIndex-2] and plan[slotIndex-1]
    4. Internal `pickForSlot(pool, remainingBudget, planSoFar, slotIndex)`:
       - Filter pool to eligible: price <= remainingBudget AND !hasCuisineViolation
       - If eligible non-empty: random pick from eligible
       - Fallback 1: relax cuisine, keep budget — cheapest affordable
       - Fallback 2: budget impossible — cheapest restaurant in pool overall
    5. `generateWeeklyPlan(pool, weeklyBudget)`:
       - If pool.length === 0, throw Error('Restaurant pool cannot be empty')
       - Loop i=0..4: pick = pickForSlot(pool, remainingBudget, days, i); push; decrement remaining
       - Return { days, totalCost: weeklyBudget - remainingBudget, weeklyBudget }

    Anti-patterns to avoid (from research):
    - NO recursive backtracking (causes infinite loop on low budget)
    - NO pre-divided daily budget (weeklyBudget / 5 fails with uneven prices)
    - NO throwing on impossible budget (return fallback instead)
    - NO global retry counter (per-slot approach via filtering)
  </implementation>
</feature>

<verification>
1. `npx vitest run` — all generateWeeklyPlan tests pass
2. No test uses `any` type — all properly typed
3. Budget constraint verified statistically (100 iterations)
4. Cuisine diversity verified statistically (100 iterations)
5. Edge cases (impossible budget, single restaurant, empty pool) all covered
</verification>

<success_criteria>
- `npx vitest run` passes with 0 failures
- generateWeeklyPlan always returns 5 days
- Budget never exceeded for satisfiable budgets (verified over 100 runs)
- No 3-consecutive same cuisine (verified over 100 runs)
- Impossible budget returns fallback, does not throw
- Empty pool throws (only throw case)
</success_criteria>

<output>
After completion, create `.planning/phases/03-recommendation-algorithm/03-02-SUMMARY.md`
</output>
