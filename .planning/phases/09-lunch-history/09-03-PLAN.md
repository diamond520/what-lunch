---
phase: 09-lunch-history
plan: "03"
type: tdd
wave: 2
depends_on:
  - "09-01"
files_modified:
  - __tests__/history.test.ts
autonomous: true
requirements:
  - HIST-03

must_haves:
  truths:
    - "getRecentlyVisitedIds correctly identifies restaurants visited within N business days"
    - "Business day counting skips weekends (Sat/Sun)"
    - "splitPoolByHistory separates unvisited from full pool"
    - "All history unit tests pass with npx vitest run"
  artifacts:
    - path: "__tests__/history.test.ts"
      provides: "Unit tests for getRecentlyVisitedIds and splitPoolByHistory"
      exports: []
  key_links:
    - from: "__tests__/history.test.ts"
      to: "src/lib/history.ts"
      via: "direct import of pure functions"
      pattern: "from.*@/lib/history"
---

<objective>
TDD the two pure functions in history.ts — getRecentlyVisitedIds (business day calculation) and splitPoolByHistory (pool filtering) — using the RED-GREEN-REFACTOR cycle.

Purpose: Business day logic is a classic TDD candidate with clear I/O contracts. Tests prevent regressions as the lookback config is adjusted.
Output: `__tests__/history.test.ts` with comprehensive unit tests for both functions, all passing.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@src/lib/history.ts
@__tests__/recommend.test.ts
</context>

<feature>
  <name>getRecentlyVisitedIds and splitPoolByHistory unit tests</name>
  <files>__tests__/history.test.ts, src/lib/history.ts</files>
  <behavior>
getRecentlyVisitedIds(entries, lookbackDays) behavior:
  - entries=[], lookbackDays=5 -> Set {} (empty)
  - entry with today's date, lookbackDays=5 -> Set containing that restaurantId (today is within 5 business days)
  - entry dated exactly 5 business days ago (Mon-Fri only), lookbackDays=5 -> Set containing restaurantId (boundary is inclusive)
  - entry dated 6 business days ago, lookbackDays=5 -> Set {} (outside window)
  - weekend days (Sat, Sun) are SKIPPED when counting backwards — e.g., if today is Monday, "1 business day ago" is Friday (not Sunday)
  - multiple entries: returns Set of all recently visited restaurantIds
  - duplicate restaurantId across multiple entries: Set deduplicates

splitPoolByHistory({ id: string }[], Set<string>) behavior:
  - empty recentIds -> primary === full pool, fallback === full pool
  - all pool items in recentIds -> primary === [], fallback === full pool
  - some in recentIds -> primary contains only unvisited, fallback contains all
  - does NOT mutate the original pool array

Test cases for business day calculation must use fixed "today" dates to be deterministic. The function uses `new Date()` internally, so tests must either:
  - Mock `Date` using vi.setSystemTime() (Vitest supports this via vi.useFakeTimers)
  - OR pass today as a parameter — but getRecentlyVisitedIds does not accept today as parameter per the plan 09-01 signature

Use vi.useFakeTimers() + vi.setSystemTime(new Date('2026-02-19')) (a Thursday) for controlled date testing. Call vi.useRealTimers() in afterEach.

Example business day scenarios anchored to Thursday 2026-02-19:
  - 1 business day back from Thursday = Wednesday 2026-02-18
  - 5 business days back from Thursday 2026-02-19 = Thursday 2026-02-12 (skip weekend: 19,18,17,16,13,12 — count weekdays only)
  - 5 business days back from Monday 2026-02-16 = Monday 2026-02-09 (skip 14,15 weekend)
  </behavior>
  <implementation>
src/lib/history.ts already implements these functions (written in plan 09-01). This TDD plan only writes tests. If tests reveal a bug in the implementation, fix the implementation to make tests green.

Test file structure:
- Use `describe('getRecentlyVisitedIds', ...)` and `describe('splitPoolByHistory', ...)`
- Import from `@/lib/history` (path alias configured in vitest.config.mts)
- vitest.config.mts uses `environment: 'jsdom'` globally — no file-level override needed
- Use `vi` from 'vitest' for fake timers
- Helper to create entries: `function entry(date: string, restaurantId: string): LunchHistoryEntry`
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Write failing tests for getRecentlyVisitedIds and splitPoolByHistory</name>
  <files>__tests__/history.test.ts</files>
  <action>
Create `__tests__/history.test.ts` with all tests written BEFORE any implementation changes. Tests should be written to describe correct behavior — they will fail only if the implementation has bugs (plan 09-01 may have already implemented correctly, in which case tests go green immediately).

```ts
import { describe, test, expect, vi, afterEach } from 'vitest'
import { getRecentlyVisitedIds, splitPoolByHistory } from '@/lib/history'
import type { LunchHistoryEntry } from '@/lib/history'

function makeEntry(date: string, restaurantId: string, restaurantName = 'Test'): LunchHistoryEntry {
  return { id: crypto.randomUUID(), date, restaurantId, restaurantName }
}

describe('getRecentlyVisitedIds', () => {
  afterEach(() => {
    vi.useRealTimers()
  })

  // Fixed "today" = Thursday 2026-02-19
  // Business days back from Thu 2026-02-19:
  //   1 bd = Wed 2026-02-18
  //   2 bd = Tue 2026-02-17
  //   3 bd = Mon 2026-02-16
  //   4 bd = Fri 2026-02-13
  //   5 bd = Thu 2026-02-12

  test('empty entries returns empty set', () => {
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2026-02-19'))
    expect(getRecentlyVisitedIds([], 5).size).toBe(0)
  })

  test('entry with today date is included (within window)', () => {
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2026-02-19'))
    const entries = [makeEntry('2026-02-19', 'r1')]
    const result = getRecentlyVisitedIds(entries, 5)
    expect(result.has('r1')).toBe(true)
  })

  test('entry at exact cutoff boundary is included (inclusive)', () => {
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2026-02-19'))
    // 5 business days back from 2026-02-19 = 2026-02-12
    const entries = [makeEntry('2026-02-12', 'r2')]
    const result = getRecentlyVisitedIds(entries, 5)
    expect(result.has('r2')).toBe(true)
  })

  test('entry one day before cutoff is excluded', () => {
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2026-02-19'))
    // 6 business days back from 2026-02-19 = 2026-02-11
    const entries = [makeEntry('2026-02-11', 'r3')]
    const result = getRecentlyVisitedIds(entries, 5)
    expect(result.has('r3')).toBe(false)
  })

  test('weekends are skipped when counting back from Monday', () => {
    vi.useFakeTimers()
    // Monday 2026-02-16
    vi.setSystemTime(new Date('2026-02-16'))
    // 1 business day back from Mon = Fri 2026-02-13 (skips Sat 2026-02-14, Sun 2026-02-15)
    const fridayEntry = [makeEntry('2026-02-13', 'r4')]
    const result = getRecentlyVisitedIds(fridayEntry, 1)
    expect(result.has('r4')).toBe(true)

    // Saturday 2026-02-14 should NOT be in window for lookback=1 from Monday
    const saturdayEntry = [makeEntry('2026-02-14', 'r5')]
    const result2 = getRecentlyVisitedIds(saturdayEntry, 1)
    expect(result2.has('r5')).toBe(false)
  })

  test('multiple entries — all recent ones returned', () => {
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2026-02-19'))
    const entries = [
      makeEntry('2026-02-19', 'r1'),
      makeEntry('2026-02-18', 'r2'),
      makeEntry('2026-02-10', 'r3'), // too old
    ]
    const result = getRecentlyVisitedIds(entries, 5)
    expect(result.has('r1')).toBe(true)
    expect(result.has('r2')).toBe(true)
    expect(result.has('r3')).toBe(false)
  })

  test('duplicate restaurantId is deduplicated in Set', () => {
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2026-02-19'))
    const entries = [
      makeEntry('2026-02-19', 'r1'),
      makeEntry('2026-02-18', 'r1'), // same restaurant, different day
    ]
    const result = getRecentlyVisitedIds(entries, 5)
    expect(result.size).toBe(1)
    expect(result.has('r1')).toBe(true)
  })

  test('lookback=1 from Thursday: only today and yesterday (Wed) in window', () => {
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2026-02-19')) // Thu
    // 1 business day back = Wed 2026-02-18 (cutoff)
    const entries = [
      makeEntry('2026-02-19', 'r1'), // today — in
      makeEntry('2026-02-18', 'r2'), // 1 bd ago — in (boundary)
      makeEntry('2026-02-17', 'r3'), // 2 bd ago — out
    ]
    const result = getRecentlyVisitedIds(entries, 1)
    expect(result.has('r1')).toBe(true)
    expect(result.has('r2')).toBe(true)
    expect(result.has('r3')).toBe(false)
  })
})

describe('splitPoolByHistory', () => {
  const pool = [
    { id: 'a', name: 'A' },
    { id: 'b', name: 'B' },
    { id: 'c', name: 'C' },
  ]

  test('empty recentIds — primary is full pool', () => {
    const { primary, fallback } = splitPoolByHistory(pool, new Set())
    expect(primary).toHaveLength(3)
    expect(fallback).toHaveLength(3)
  })

  test('all items recent — primary is empty, fallback is full', () => {
    const { primary, fallback } = splitPoolByHistory(pool, new Set(['a', 'b', 'c']))
    expect(primary).toHaveLength(0)
    expect(fallback).toHaveLength(3)
  })

  test('some items recent — primary contains only unvisited', () => {
    const { primary, fallback } = splitPoolByHistory(pool, new Set(['a']))
    expect(primary.map((r) => r.id)).toEqual(['b', 'c'])
    expect(fallback).toHaveLength(3)
  })

  test('does not mutate original pool', () => {
    const original = [...pool]
    splitPoolByHistory(pool, new Set(['a']))
    expect(pool).toEqual(original)
  })

  test('works with Restaurant-shaped objects (duck typing)', () => {
    const restaurants = [
      { id: 'r1', name: 'R1', type: 'chi', price: 100, distance: 100, rating: 4.0 },
      { id: 'r2', name: 'R2', type: 'jp', price: 80, distance: 200, rating: 4.5 },
    ]
    const { primary } = splitPoolByHistory(restaurants, new Set(['r1']))
    expect(primary).toHaveLength(1)
    expect(primary[0].id).toBe('r2')
  })
})
```

Run tests: `npx vitest run __tests__/history.test.ts`

If any tests FAIL because of a bug in the implementation in history.ts (not the test logic), fix the implementation in src/lib/history.ts to make them pass. Common issues to check:
- Business day cutoff off-by-one (inclusive vs exclusive boundary)
- UTC vs local date in getRecentlyVisitedIds (must use local date, same as `new Date().toLocaleDateString('sv')`)
- Weekend skipping logic (sat=6, sun=0 in getDay())

Commit after RED (even if tests pass immediately — commit demonstrates intent):
`git commit -m "test(09-03): add unit tests for history business day logic and pool split"`
  </action>
  <verify>Run `npx vitest run __tests__/history.test.ts` — all tests must pass (green). If any fail, fix the implementation in src/lib/history.ts until all pass.</verify>
  <done>All tests in __tests__/history.test.ts pass. `npx vitest run` (full suite) still passes — no regressions in other test files.</done>
</task>

</tasks>

<verification>
- `npx vitest run` passes (all test files, no regressions)
- `npx vitest run __tests__/history.test.ts` shows all tests green
- Business day scenarios verified: weekends skipped, boundary inclusive, deduplication correct
- splitPoolByHistory: empty recentIds, all recent, partial, non-mutation all tested
- `npx tsc --noEmit` still passes (test file compiles cleanly)
</verification>

<success_criteria>
All unit tests pass. The business day logic and pool-split functions are verified correct by automated tests. Future changes to history.ts will be protected by this test suite.
</success_criteria>

<output>
After completion, create `.planning/phases/09-lunch-history/09-03-SUMMARY.md`
</output>
