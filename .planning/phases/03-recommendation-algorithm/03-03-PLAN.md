---
phase: 03-recommendation-algorithm
plan: 03
type: tdd
wave: 3
depends_on: ["03-02"]
files_modified:
  - src/lib/recommend.ts
  - __tests__/recommend.test.ts
autonomous: true

must_haves:
  truths:
    - "A single day's pick can be swapped without changing any other day's pick"
    - "Re-rolling a slot respects the weekly budget constraint"
    - "Re-rolling a slot does not create 3 consecutive same-cuisine violations in either direction"
  artifacts:
    - path: "src/lib/recommend.ts"
      provides: "rerollSlot function"
      exports: ["rerollSlot"]
    - path: "__tests__/recommend.test.ts"
      provides: "Unit tests for rerollSlot"
      contains: "describe.*rerollSlot"
  key_links:
    - from: "src/lib/recommend.ts (rerollSlot)"
      to: "src/lib/recommend.ts (pickForSlot)"
      via: "rerollSlot calls internal pickForSlot with budget = weeklyBudget - sum of other 4"
      pattern: "pickForSlot"
    - from: "src/lib/recommend.ts (rerollSlot)"
      to: "src/lib/recommend.ts (hasCuisineViolation)"
      via: "cuisine check must consider BOTH neighbors of the re-rolled slot"
      pattern: "hasCuisineViolation"
---

<objective>
TDD the `rerollSlot` function: write failing tests first, then implement the per-slot swap that preserves budget and cuisine constraints while checking both forward and backward neighbors.

Purpose: Re-roll is the key UX feature — users swap one day without regenerating everything. The tricky part is checking cuisine diversity in BOTH directions (before and after the re-rolled slot), which the research flagged as Pitfall 4.
Output: Complete, tested `rerollSlot` in `src/lib/recommend.ts`, full test suite in `__tests__/recommend.test.ts`.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-recommendation-algorithm/03-RESEARCH.md
@.planning/phases/03-recommendation-algorithm/03-02-SUMMARY.md

@src/lib/types.ts
@src/lib/restaurants.ts
@src/lib/recommend.ts
@__tests__/recommend.test.ts
</context>

<feature>
  <name>rerollSlot</name>
  <files>src/lib/recommend.ts, __tests__/recommend.test.ts</files>
  <behavior>
    rerollSlot(plan: WeeklyPlan, slotIndex: number, pool: Restaurant[]) => WeeklyPlan

    Constraints:
    - Only the target slotIndex changes; other 4 days are identical (same object references)
    - New plan.totalCost <= plan.weeklyBudget (when satisfiable)
    - No 3-consecutive same cuisine in the resulting plan — checked BOTH directions:
      * Backward: plan[i-2], plan[i-1], newPick must not all be same type
      * Forward: newPick, plan[i+1], plan[i+2] must not all be same type
      * Bridge: plan[i-1], newPick, plan[i+1] must not all be same type
    - slotIndex must be 0-4

    Test cases:
    - Reroll slot 2: days[0], days[1], days[3], days[4] unchanged (same references via toBe)
    - Reroll slot 0: days[1], days[2], days[3], days[4] unchanged
    - Reroll slot 4: days[0], days[1], days[2], days[3] unchanged
    - Reroll preserves budget: new totalCost <= weeklyBudget
    - Reroll with forward neighbor check: if slots 3 and 4 are same cuisine, slot 2 re-roll must not pick that cuisine (would create 3-consecutive at positions 2,3,4)
    - Reroll with backward neighbor check: if slots 0 and 1 are same cuisine, slot 2 re-roll must not pick that cuisine (would create 3-consecutive at positions 0,1,2)
    - Reroll with bridge check: if slot 1 and slot 3 are same cuisine, slot 2 re-roll must not pick that cuisine (would create 3-consecutive at 1,2,3)

    Statistical validation (N=100):
    - Budget maintained every iteration
    - Cuisine diversity maintained every iteration
    - Other slots never change
  </behavior>
  <implementation>
    The key change from the research skeleton: `hasCuisineViolation` must be enhanced to check FORWARD neighbors too, not just backward. The research flagged this as Open Question #1 and recommended "yes, check both directions."

    Updated `hasCuisineViolation(plan, slotIndex, candidate)`:
    - Check backward: plan[i-2]?.type === plan[i-1]?.type === candidate.type
    - Check forward: candidate.type === plan[i+1]?.type === plan[i+2]?.type
    - Check bridge: plan[i-1]?.type === candidate.type === plan[i+1]?.type
    - Return true if ANY of these creates a 3-consecutive run

    NOTE: This change to hasCuisineViolation also improves generateWeeklyPlan (it's shared), but since generateWeeklyPlan fills slots left-to-right, forward slots don't exist yet during generation — so the forward check is a no-op for generation and only matters for re-roll. This is correct and safe.

    `rerollSlot(plan, slotIndex, pool)`:
    1. Calculate budget for new pick: weeklyBudget - sum of other 4 days' prices
    2. Build a temporary plan array with a placeholder at slotIndex (for neighbor checking)
    3. Call pickForSlot with the full plan context so hasCuisineViolation can check both directions
    4. Replace slotIndex in days array, recalculate totalCost
    5. Return new WeeklyPlan (immutable — do not mutate input)
  </implementation>
</feature>

<verification>
1. `npx vitest run` — ALL tests pass (both generateWeeklyPlan and rerollSlot)
2. Re-roll only changes target slot (verified with toBe reference checks)
3. Forward cuisine check verified with crafted test case
4. Budget preserved after re-roll (verified statistically, 100 iterations)
5. `npm run build` still passes (TypeScript compilation check)
</verification>

<success_criteria>
- `npx vitest run` passes with 0 failures
- rerollSlot changes only the target slot (other 4 are same object references)
- Budget constraint maintained after re-roll
- Cuisine diversity maintained in both directions after re-roll
- `npm run build` passes (no TypeScript errors introduced)
- All phase success criteria from ROADMAP.md are satisfied:
  1. Weekly plan of 5 restaurants from single function call with budget -- generateWeeklyPlan
  2. Plan costs no more than specified budget -- budget enforcement
  3. No more than 2 consecutive same cuisine -- cuisine diversity
  4. Single day swap without changing others -- rerollSlot
  5. Algorithm terminates in all cases with graceful fallback -- bounded iteration + fallback
</success_criteria>

<output>
After completion, create `.planning/phases/03-recommendation-algorithm/03-03-SUMMARY.md`
</output>
