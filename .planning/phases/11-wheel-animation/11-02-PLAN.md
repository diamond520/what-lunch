---
phase: 11-wheel-animation
plan: 02
type: execute
wave: 2
depends_on: [11-01]
files_modified:
  - src/app/page.tsx
  - __tests__/integration.test.tsx
autonomous: false
requirements: []

must_haves:
  truths:
    - "Clicking '產生本週午餐計畫' starts animation across all 5 day slots simultaneously"
    - "Each day slot cycles through different restaurant names independently (offset indices, not in sync)"
    - "After ~2.5 seconds all 5 slots settle and reveal the final day names, cuisine badges, prices"
    - "Clicking '重抽' on one day slot cycles only that slot's name while others remain settled"
    - "The '產生本週午餐計畫' button and all '重抽' buttons are disabled during any animation"
    - "User can press Space/Enter/Escape to skip full-plan animation and reveal all results immediately"
    - "Animation works the same on both weekday and weekend pages (weekend verified in 11-01)"
    - "All existing integration tests pass with fake timers — no timeouts"
  artifacts:
    - path: "src/app/page.tsx"
      provides: "Weekday page with inline multi-slot animation state"
      contains: "genIntervalRef"
    - path: "__tests__/integration.test.tsx"
      provides: "Integration tests updated with fake timers"
      contains: "vi.useFakeTimers"
  key_links:
    - from: "src/app/page.tsx"
      to: "setDisplayNames / setAnimatingSlots"
      via: "inline setInterval/setTimeout in handleGenerate and handleReroll"
      pattern: "genIntervalRef|rerollIntervalRef"
    - from: "__tests__/integration.test.tsx"
      to: "vi.advanceTimersByTime"
      via: "fake timers before clicking generate button"
      pattern: "advanceTimersByTime"
---

<objective>
Wire multi-slot animation into the weekday picker page and update integration tests to use fake timers.

Purpose: The weekday page has 5 independent day slots. The "generate plan" action must animate all 5 slots simultaneously; per-slot "重抽" animates only the affected slot. This uses inline timer state (not the `useSlotAnimation` hook — hooks cannot be called in a loop per Rules of Hooks). After this plan, all 5 success criteria for Phase 11 are met.

Output: Updated `src/app/page.tsx` with animation, updated `__tests__/integration.test.tsx` with fake timers, human verification checkpoint for both pages.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-wheel-animation/11-RESEARCH.md
@.planning/phases/11-wheel-animation/11-01-SUMMARY.md

@src/app/page.tsx
@__tests__/integration.test.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add inline multi-slot animation to weekday page</name>
  <files>src/app/page.tsx</files>
  <action>
Update `src/app/page.tsx` to add animation for both "generate plan" (all 5 slots) and per-slot "重抽" (1 slot). The existing `generateWeeklyPlan`, `rerollSlot` algorithm functions remain UNCHANGED — animation only overlays the display.

**New state to add** (after existing useState declarations):
```typescript
// Animation state — separate from plan (never mutate plan for animation display)
const [displayNames, setDisplayNames] = useState<(string | null)[]>(Array(5).fill(null))
const [animatingSlots, setAnimatingSlots] = useState<Set<number>>(new Set())
const genIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null)
const genTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)
const rerollIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null)
const rerollTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)
```

Add `useRef` to the react import.

**`allRestaurantNames` memo** (add after state declarations):
```typescript
const allRestaurantNames = useMemo(() => restaurants.map(r => r.name), [restaurants])
```
Add `useMemo` to the react import.

**Animation helpers**:
```typescript
function stopGenAnimation() {
  if (genIntervalRef.current) clearInterval(genIntervalRef.current)
  if (genTimeoutRef.current) clearTimeout(genTimeoutRef.current)
  genIntervalRef.current = null
  genTimeoutRef.current = null
}

function stopRerollAnimation() {
  if (rerollIntervalRef.current) clearInterval(rerollIntervalRef.current)
  if (rerollTimeoutRef.current) clearTimeout(rerollTimeoutRef.current)
  rerollIntervalRef.current = null
  rerollTimeoutRef.current = null
}
```

**Updated `handleGenerate`**:
```typescript
function handleGenerate() {
  if (restaurants.length === 0 || isNaN(budget)) return
  const newPlan = generateWeeklyPlan(restaurants, budget)
  setHistory((prev) => [newPlan, ...prev].slice(0, MAX_HISTORY))
  setSelectedIndex(0)

  stopGenAnimation()
  stopRerollAnimation()
  setAnimatingSlots(new Set([0, 1, 2, 3, 4]))

  let idx = 0
  genIntervalRef.current = setInterval(() => {
    idx++
    setDisplayNames(
      Array.from({ length: 5 }, (_, i) =>
        allRestaurantNames[(idx + i * 3) % allRestaurantNames.length] ?? null
      )
    )
  }, 80)

  genTimeoutRef.current = setTimeout(() => {
    stopGenAnimation()
    setDisplayNames(Array(5).fill(null))
    setAnimatingSlots(new Set())
  }, 2500)
}
```

**Updated `handleReroll`**:
```typescript
function handleReroll(index: number) {
  if (!plan) return
  const updated = rerollSlot(plan, index, restaurants)
  setHistory((prev) => prev.map((p, i) => (i === selectedIndex ? updated : p)))

  stopRerollAnimation()
  setAnimatingSlots(new Set([index]))

  let idx = 0
  rerollIntervalRef.current = setInterval(() => {
    idx++
    setDisplayNames((prev) => {
      const next = [...prev]
      next[index] = allRestaurantNames[idx % allRestaurantNames.length] ?? null
      return next
    })
  }, 80)

  rerollTimeoutRef.current = setTimeout(() => {
    stopRerollAnimation()
    setDisplayNames((prev) => {
      const next = [...prev]
      next[index] = null
      return next
    })
    setAnimatingSlots(new Set())
  }, 2500)
}
```

**Skip-by-keypress effect** (add after state declarations, before return):
```typescript
const isAnyAnimating = animatingSlots.size > 0

useEffect(() => {
  if (!isAnyAnimating) return
  const handler = (e: KeyboardEvent) => {
    if (['Space', 'Enter', 'Escape'].includes(e.code)) {
      e.preventDefault()
      stopGenAnimation()
      stopRerollAnimation()
      setDisplayNames(Array(5).fill(null))
      setAnimatingSlots(new Set())
    }
  }
  document.addEventListener('keydown', handler)
  return () => document.removeEventListener('keydown', handler)
}, [isAnyAnimating])
```

**Button changes**:
- "產生本週午餐計畫" button: add `disabled={restaurants.length === 0 || isAnyAnimating}`
- Each "重抽" button: add `disabled={isAnyAnimating}`

**Day card rendering changes** (inside the `.map((r, i) => ...)` block):
```typescript
const slotIsAnimating = animatingSlots.has(i)
const nameToShow = slotIsAnimating && displayNames[i] !== null
  ? displayNames[i]!
  : r.name
```

Replace the inner card JSX:
- Card wrapper: add `onClick={slotIsAnimating ? () => { stopGenAnimation(); stopRerollAnimation(); setDisplayNames(Array(5).fill(null)); setAnimatingSlots(new Set()) } : undefined}` and `className={slotIsAnimating ? 'cursor-pointer ...' : '...'}`
- Restaurant name `<p className="font-semibold">`: render `{nameToShow}`
- Cuisine badge, price, distance: show skeleton during animation, real values when settled:
  ```tsx
  {slotIsAnimating ? (
    <>
      <div className="h-5 w-16 bg-muted animate-pulse rounded" />
      <div className="h-4 w-20 bg-muted animate-pulse rounded" />
      <div className="h-4 w-24 bg-muted animate-pulse rounded" />
    </>
  ) : (
    <div className="animate-in fade-in zoom-in-95 duration-300">
      <span
        className="inline-flex items-center rounded-md px-2 py-0.5 text-xs font-medium text-white w-fit"
        style={{ backgroundColor: CUISINE_META[r.type].color }}
      >
        {CUISINE_META[r.type].label}
      </span>
      <p className="text-sm">NT$ {r.price}</p>
      <p className="text-sm text-muted-foreground">{r.distance} m・⭐ {r.rating}</p>
    </div>
  )}
  ```
- "重抽" button: add `disabled={isAnyAnimating}` and show skip hint text on animating slot:
  ```tsx
  {slotIsAnimating && (
    <p className="text-xs text-muted-foreground text-center">點擊跳過</p>
  )}
  ```

**IMPORTANT — guard for allRestaurantNames.length === 0**: The `idx % allRestaurantNames.length` will produce NaN/undefined if the array is empty. Add guard in handleGenerate: `if (allRestaurantNames.length === 0) return` (restaurants.length === 0 check already guards this, but belt-and-suspenders).
  </action>
  <verify>Run `npx tsc --noEmit` — no TypeScript errors. Run `npm run dev` locally and verify: clicking "產生本週午餐計畫" shows 5 slots cycling names independently for ~2.5s then reveals plan. Clicking "重抽" on one slot cycles only that slot.</verify>
  <done>Weekday page compiles clean, all 5 day slots animate on generate, single slot animates on reroll, skip via keypress or card click works, buttons disabled during animation, settled card fades in</done>
</task>

<task type="auto">
  <name>Task 2: Update integration tests to use fake timers</name>
  <files>__tests__/integration.test.tsx</files>
  <action>
The existing integration tests click the "產生本週午餐計畫" and "重抽" buttons and immediately assert on plan output. After Plan 11-01/02, these button clicks trigger 2500ms animations. Tests must use fake timers and advance past the animation before asserting.

**Changes to `__tests__/integration.test.tsx`**:

1. Add `vi` and `afterEach` to the vitest import:
   ```typescript
   import { describe, test, expect, beforeEach, afterEach, vi } from 'vitest'
   ```

2. Add `act` to the @testing-library/react import:
   ```typescript
   import { render, screen, act } from '@testing-library/react'
   ```

3. Add a global `afterEach` at the top level (after the existing `beforeEach`):
   ```typescript
   afterEach(() => {
     vi.useRealTimers()
   })
   ```

4. For every test inside `describe('Integration: HomePage', ...)` that clicks the generate or reroll button:
   - Add `vi.useFakeTimers()` as the FIRST line of the test body (before render)
   - Change `userEvent.setup()` to `userEvent.setup({ advanceTimers: vi.advanceTimersByTime })`
   - After each button click that triggers animation, add: `act(() => { vi.advanceTimersByTime(3000) })`

   Affected HomePage tests:
   - "generates a plan" — advance after generate click
   - "reroll changes a day" — advance after generate click, advance after reroll click
   - "plan history appears after 2nd generate" — advance after each of the two generate clicks
   - "clicking history entry switches displayed plan" — advance after each of the two generate clicks

5. Tests inside `describe('Integration: RestaurantsPage', ...)` do NOT click generate/reroll — no changes needed there.

**Resulting test structure example**:
```typescript
test('generates a plan', async () => {
  vi.useFakeTimers()
  const user = userEvent.setup({ advanceTimers: vi.advanceTimersByTime })
  renderHomePage()

  await user.click(screen.getByRole('button', { name: '產生本週午餐計畫' }))
  act(() => { vi.advanceTimersByTime(3000) })

  expect(screen.getByText('星期一')).toBeInTheDocument()
  expect(screen.getByText('星期五')).toBeInTheDocument()
  expect(screen.getByText(/本週總花費/)).toBeInTheDocument()
})
```

**Note on assertions during animation**: After button click but BEFORE `act(vi.advanceTimersByTime(3000))`, the plan cards are shown but names are cycling display values (not restaurant names from data). Do NOT assert on specific restaurant names — only assert on structural elements like day labels ("星期一") and summary text ("本週總花費") which are unaffected by animation. The existing assertions already do this correctly.
  </action>
  <verify>Run `npx vitest run __tests__/integration.test.tsx` — all 7 tests pass, no timeouts, no "exceeded timeout" errors</verify>
  <done>All integration tests pass with fake timers; no test takes longer than 1 second; RestaurantsPage tests unchanged and passing</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Slot-machine animation on both the weekend and weekday picker pages:
    - Weekend page: single slot cycles names for 2.5s then reveals full restaurant card with fade-in
    - Weekday page: all 5 day slots cycle independently on generate, single slot cycles on reroll
    - Skip works via Space/Enter/Escape keypress or clicking the animating card area
    - Buttons disabled during animation
    - All tests passing with fake timers
  </what-built>
  <how-to-verify>
    Run `npm run dev` and open http://localhost:3000

    **Weekend page (http://localhost:3000/weekend):**
    1. Click "隨機推薦" — verify restaurant names cycle rapidly in the card for ~2.5 seconds before settling
    2. After settling, verify the full card (name, cuisine badge, price, distance, rating) fades in smoothly
    3. Click "隨機推薦" again (or "換一間") — verify a new animation cycle starts
    4. Start an animation, then press Escape — verify animation stops immediately and result appears
    5. Start an animation, then click the animating card — verify animation skips to result
    6. Verify "隨機推薦" and "換一間" buttons are grayed out/disabled during animation

    **Weekday page (http://localhost:3000):**
    7. Click "產生本週午餐計畫" — verify all 5 day cards show independently cycling restaurant names for ~2.5s
    8. After settling, verify all 5 cards reveal their final restaurant names, cuisine badges, and prices
    9. Click "重抽" on one day card — verify only that card cycles while others stay settled
    10. Start full-plan animation, press Escape — verify all slots immediately reveal results
    11. Verify "產生本週午餐計畫" and all "重抽" buttons are disabled during animation

    **Regression check:**
    12. Navigate to /restaurants — confirm restaurant management page works normally
    13. Run `npx vitest run` — verify full test suite passes
  </how-to-verify>
  <resume-signal>Type "approved" if animation works on both pages, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete (before human verify):
1. `npx tsc --noEmit` — zero TypeScript errors
2. `npx vitest run` — full test suite passes (integration + weekend-page + use-slot-animation tests all green)
3. `npm run build` — production build completes without errors
</verification>

<success_criteria>
- Weekday page has 5-slot animation on "產生本週午餐計畫" (all 5 cycle independently)
- Weekday page has single-slot animation on "重抽" (only that slot cycles)
- Skip works via keypress (Space/Enter/Escape) and card click on weekday page
- All integration tests pass with fake timers (no timeouts)
- `npm run build` passes clean
- Human verification approved for both pages
</success_criteria>

<output>
After completion, create `.planning/phases/11-wheel-animation/11-02-SUMMARY.md`
</output>
