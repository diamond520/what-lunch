---
phase: 08-cuisine-filter
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/app/page.tsx
autonomous: false
requirements: []

must_haves:
  truths:
    - "Picker page shows a segmented 排除/鎖定 toggle above colored cuisine chips"
    - "Tapping a cuisine chip toggles it on/off with clear visual feedback (full opacity vs dimmed)"
    - "In exclude mode, selected cuisines are removed from the pool before generating a plan"
    - "In lock mode, only selected cuisines remain in the pool"
    - "A 重置 reset button clears all chip selections and returns to exclude mode"
    - "Inline warning appears below chips when filtered pool has fewer than 5 restaurants"
    - "Changing filter mode or chip selection auto-clears the current plan"
    - "Filter state persists in localStorage across page reloads"
    - "Re-rolling a single day respects the current filter"
    - "Lock mode with only 1 cuisine type relaxes the diversity constraint"
  artifacts:
    - path: "src/app/page.tsx"
      provides: "Cuisine filter UI section, filter state, localStorage persistence, filtered pool integration"
      min_lines: 150
  key_links:
    - from: "src/app/page.tsx"
      to: "src/lib/recommend.ts"
      via: "import applyFilter, FilterMode"
      pattern: "import.*applyFilter.*FilterMode.*from.*recommend"
    - from: "src/app/page.tsx"
      to: "src/lib/types.ts"
      via: "import CUISINE_META, CuisineType for chip rendering"
      pattern: "import.*CUISINE_META.*CuisineType.*from.*types"
    - from: "src/app/page.tsx"
      to: "localStorage"
      via: "what-lunch-cuisine-filter key for persistence"
      pattern: "what-lunch-cuisine-filter"
---

<objective>
Add the cuisine filter UI to the picker page: segmented mode toggle (排除/鎖定), colored cuisine chips, reset button, inline warning, and localStorage persistence. Wire filter state to `applyFilter` so both generate and re-roll respect the filter.

Purpose: Users can control which cuisine types appear in their weekly plan by excluding unwanted types or locking to preferred types.

Output: Fully functional cuisine filter section on the picker page with persistence and algorithm integration.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-cuisine-filter/08-01-SUMMARY.md
@src/app/page.tsx
@src/lib/recommend.ts
@src/lib/types.ts
@src/lib/restaurant-context.tsx
@src/components/ui/tabs.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cuisine filter UI and wire to algorithm on picker page</name>
  <files>src/app/page.tsx</files>
  <action>
Modify `src/app/page.tsx` to add the cuisine filter section. All changes are in this single file.

**1. New imports:**
```typescript
import { useEffect } from 'react'  // add to existing useState import
import { applyFilter, type FilterMode } from '@/lib/recommend'  // add to existing recommend import
import type { CuisineType } from '@/lib/types'  // add CuisineType to existing types import
import { Tabs, TabsList, TabsTrigger } from '@/components/ui/tabs'
```

**2. Constants and helpers (top of file, below existing constants):**
```typescript
const FILTER_STORAGE_KEY = 'what-lunch-cuisine-filter'
const POOL_WARNING_THRESHOLD = 5

interface StoredFilter {
  mode: FilterMode
  selected: CuisineType[]
}

function readStoredFilter(): StoredFilter {
  if (typeof window === 'undefined') return { mode: 'exclude', selected: [] }
  try {
    const stored = localStorage.getItem(FILTER_STORAGE_KEY)
    if (!stored) return { mode: 'exclude', selected: [] }
    return JSON.parse(stored) as StoredFilter
  } catch {
    return { mode: 'exclude', selected: [] }
  }
}
```

**3. Filter state (inside HomePage component, after existing state):**
```typescript
const [filterMode, setFilterMode] = useState<FilterMode>(() => readStoredFilter().mode)
const [selectedCuisines, setSelectedCuisines] = useState<Set<CuisineType>>(
  () => new Set(readStoredFilter().selected),
)
```

**4. Computed filtered pool and warning (after state declarations, before handlers):**
```typescript
const filteredPool = applyFilter(restaurants, filterMode, [...selectedCuisines])
const showWarning = isHydrated && selectedCuisines.size > 0 && filteredPool.length < POOL_WARNING_THRESHOLD
const relaxDiversity = filterMode === 'lock' && selectedCuisines.size === 1
```

**5. localStorage persistence (useEffect, after computed values):**
```typescript
useEffect(() => {
  if (!isHydrated) return
  try {
    localStorage.setItem(
      FILTER_STORAGE_KEY,
      JSON.stringify({ mode: filterMode, selected: [...selectedCuisines] }),
    )
  } catch {
    // Ignore storage errors
  }
}, [filterMode, selectedCuisines, isHydrated])
```

**6. Filter change helpers (above handleGenerate):**
```typescript
function handleFilterModeChange(newMode: string) {
  setFilterMode(newMode as FilterMode)
  // Keep selections when switching modes (per Claude's discretion — user may want to compare)
  // Auto-clear plan since semantics changed
  setHistory([])
  setSelectedIndex(0)
}

function toggleCuisine(cuisine: CuisineType) {
  setSelectedCuisines((prev) => {
    const next = new Set(prev)
    if (next.has(cuisine)) {
      next.delete(cuisine)
    } else {
      next.add(cuisine)
    }
    return next
  })
  // Auto-clear plan on filter change (consistent with budget change behavior)
  setHistory([])
  setSelectedIndex(0)
}

function resetFilter() {
  setFilterMode('exclude')
  setSelectedCuisines(new Set())
  setHistory([])
  setSelectedIndex(0)
}
```

**7. Update handleGenerate to use filtered pool:**
```typescript
function handleGenerate() {
  if (filteredPool.length === 0 || isNaN(budget)) return
  const newPlan = generateWeeklyPlan(filteredPool, budget, { relaxDiversity })
  setHistory((prev) => [newPlan, ...prev].slice(0, MAX_HISTORY))
  setSelectedIndex(0)
}
```
Note: Guard changed from `restaurants.length === 0` to `filteredPool.length === 0`.

**8. Update handleReroll to use filtered pool:**
```typescript
function handleReroll(index: number) {
  if (!plan) return
  const updated = rerollSlot(plan, index, filteredPool, { relaxDiversity })
  setHistory((prev) => prev.map((p, i) => (i === selectedIndex ? updated : p)))
}
```
Note: Uses `filteredPool` instead of `restaurants`, and passes `{ relaxDiversity }`.

**9. Filter section JSX — insert BELOW the budget row, ABOVE the plan grid:**

After the closing `</div>` of the budget row (`flex items-center gap-4 mb-6`), add:

```jsx
{/* Cuisine filter section */}
<div className="mb-6 space-y-3">
  <div className="flex items-center gap-3">
    <Tabs value={filterMode} onValueChange={handleFilterModeChange}>
      <TabsList>
        <TabsTrigger value="exclude">排除</TabsTrigger>
        <TabsTrigger value="lock">鎖定</TabsTrigger>
      </TabsList>
    </Tabs>

    <div className="flex flex-wrap items-center gap-2">
      {(Object.entries(CUISINE_META) as [CuisineType, { label: string; color: string }][]).map(
        ([key, meta]) => (
          <button
            key={key}
            onClick={() => toggleCuisine(key)}
            className={cn(
              'inline-flex items-center rounded-full px-3 py-1 text-xs font-medium text-white transition-all',
              selectedCuisines.has(key)
                ? 'opacity-100 ring-2 ring-offset-2 ring-offset-background'
                : 'opacity-40 hover:opacity-60',
            )}
            style={{
              backgroundColor: meta.color,
              ...(selectedCuisines.has(key) ? { '--tw-ring-color': meta.color } as React.CSSProperties : {}),
            }}
            aria-pressed={selectedCuisines.has(key)}
          >
            {meta.label}
          </button>
        ),
      )}
    </div>

    {selectedCuisines.size > 0 && (
      <button
        onClick={resetFilter}
        className="text-xs text-muted-foreground hover:text-foreground transition-colors"
      >
        重置
      </button>
    )}
  </div>

  {showWarning && (
    <p className="text-sm text-amber-600 dark:text-amber-400">
      {filteredPool.length === 0
        ? '目前篩選條件下沒有符合的餐廳，請調整篩選條件'
        : `目前篩選條件下只有 ${filteredPool.length} 家餐廳，可能無法填滿 5 天`}
    </p>
  )}
</div>
```

**10. Import `cn` utility:**
Add to imports: `import { cn } from '@/lib/utils'`

**11. Update the generate button disabled condition:**
Change `disabled={restaurants.length === 0}` to `disabled={filteredPool.length === 0}`.
Update the empty-restaurant message to also check filter: keep existing `restaurants.length === 0` message, but don't show it when restaurants exist but filter is too restrictive (the warning text handles that).

**Important details per locked decisions:**
- No label/header text above the filter section — chips are self-explanatory (done: no heading)
- Segmented control uses Tabs component with 排除 / 鎖定 labels (done)
- Default mode is 排除 (exclude) — done via readStoredFilter default
- 重置 reset button appears next to the filter area (done: inline, only visible when selections exist)
- Colored chips use CUISINE_META colors via inline style (done)
- Inline warning in yellow/orange (done: text-amber-600/400)
- Filter state persists in localStorage (done: useEffect write + lazy initializer read)
- Changing filter auto-clears plan (done: setHistory([]) in all change handlers)
- Filters apply to re-rolls (done: handleReroll uses filteredPool)
- Reset clears all selections and returns to exclude mode (done)
- Lock mode with 1 cuisine relaxes diversity (done: relaxDiversity computed + passed to both generate and reroll)
  </action>
  <verify>
1. `npx tsc --noEmit` — no TypeScript errors
2. `npm run build` — builds without errors
3. `npx vitest run` — all existing tests still pass
4. `npm run dev` — app starts successfully
  </verify>
  <done>
The picker page now has a cuisine filter section with:
- Segmented 排除/鎖定 toggle using Tabs component
- Colored cuisine chips derived from CUISINE_META with toggle behavior
- 重置 reset button (visible when chips are selected)
- Inline amber warning when filtered pool is too small
- localStorage persistence for filter mode and selected cuisines
- Both handleGenerate and handleReroll use the filtered pool
- Lock mode with single cuisine type passes relaxDiversity to algorithm
- Plan auto-clears when filter changes
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify cuisine filter on picker page</name>
  <what-built>
Cuisine filter UI on the picker page with exclude/lock modes, colored chips, reset button, warning text, localStorage persistence, and algorithm integration.
  </what-built>
  <how-to-verify>
1. Open http://localhost:3000 in the browser
2. **Verify filter section visible:** Below the budget row, you should see a 排除/鎖定 segmented toggle followed by 5 colored cuisine chips (中式, 日式, 韓式, 泰式, 西式)
3. **Test exclude mode (default):**
   - Click 日式 chip — it should become fully opaque with a ring
   - Click 產生本週午餐計畫 — the generated plan should NOT contain any 日式 restaurants
   - Click 重抽 on any day — the re-rolled pick should also NOT be 日式
4. **Test lock mode:**
   - Click the 鎖定 tab in the segmented toggle
   - The 日式 chip should still be selected (selections preserved across mode switch)
   - Click 產生本週午餐計畫 — the generated plan should ONLY contain 日式 restaurants
5. **Test single-cuisine lock (diversity relaxation):**
   - In 鎖定 mode, deselect all chips, then select only 中式
   - Generate a plan — all 5 days should be 中式 restaurants (no diversity constraint blocking)
6. **Test warning:**
   - In 排除 mode, select 4 out of 5 cuisine types — warning text should appear in amber
   - Select all 5 — warning should say "沒有符合的餐廳" and generate button should be disabled
7. **Test reset:**
   - Click 重置 — all chips deselect, mode returns to 排除
8. **Test persistence:**
   - Select some chips in a mode, reload the page — filter state should be preserved
9. **Test auto-clear:**
   - Generate a plan, then toggle a chip — the plan should disappear
10. **Test dark mode:** Toggle dark mode — chips, warning text, and filter section should look correct
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` — no TypeScript errors
2. `npm run build` — clean build
3. `npx vitest run` — all tests pass (including new applyFilter tests from plan 01)
4. Manual verification of filter UI on picker page
5. Exclude mode correctly removes selected cuisines from generated plans
6. Lock mode correctly limits generated plans to selected cuisines only
7. Single-cuisine lock mode produces valid plans (diversity relaxed)
8. Warning appears when filtered pool < 5 restaurants
9. Filter state persists across page reloads
10. Filter changes auto-clear existing plans
</verification>

<success_criteria>
- Segmented 排除/鎖定 toggle visible on picker page
- 5 colored cuisine chips rendered from CUISINE_META
- Exclude mode filters out selected cuisines from plans and re-rolls
- Lock mode restricts plans and re-rolls to only selected cuisines
- 重置 button clears selections and returns to exclude mode
- Amber warning shown when filtered pool is too small
- Filter state persists in localStorage
- Filter changes auto-clear current plan
- All existing tests pass
- Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/08-cuisine-filter/08-02-SUMMARY.md`
</output>
