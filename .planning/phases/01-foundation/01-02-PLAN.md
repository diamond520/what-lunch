---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/types.ts
  - lib/restaurants.ts
  - app/page.tsx
autonomous: true

must_haves:
  truths:
    - "`Restaurant` interface and `CuisineType` union are importable from `lib/types.ts`"
    - "Cuisine labels and colors exist once only — in `CUISINE_META` in `lib/types.ts` — no duplicates anywhere"
    - "All 19 default restaurants are in `DEFAULT_RESTAURANTS` in `lib/restaurants.ts`, typed as `Restaurant[]`"
    - "`npm run build` completes with no TypeScript errors"
  artifacts:
    - path: "lib/types.ts"
      provides: "CuisineType union, Restaurant interface, CUISINE_META record"
      exports: ["CUISINE_META", "CuisineType", "Restaurant"]
      contains: "as const satisfies Record"
    - path: "lib/restaurants.ts"
      provides: "DEFAULT_RESTAURANTS constant (19 restaurants)"
      exports: ["DEFAULT_RESTAURANTS"]
      contains: "satisfies Restaurant[]"
    - path: "app/page.tsx"
      provides: "Home page importing DEFAULT_RESTAURANTS"
      contains: "DEFAULT_RESTAURANTS"
  key_links:
    - from: "lib/restaurants.ts"
      to: "lib/types.ts"
      via: "import type { Restaurant }"
      pattern: "import.*Restaurant.*from.*types"
    - from: "app/page.tsx"
      to: "lib/restaurants.ts"
      via: "import { DEFAULT_RESTAURANTS }"
      pattern: "import.*DEFAULT_RESTAURANTS.*from.*restaurants"
---

<objective>
Create the single typed source of truth for all restaurant data: `lib/types.ts` (types + cuisine constants) and `lib/restaurants.ts` (19 default restaurants). Wire `app/page.tsx` to import from these files and verify the build passes with no TypeScript errors.

Purpose: This completes Phase 1. All downstream phases (algorithm, UI, restaurant management) will import from these two files. Getting the types right now prevents bugs in every subsequent phase.
Output: `lib/types.ts` and `lib/restaurants.ts` as the single source of truth, confirmed importable and type-safe.
</objective>

<execution_context>
@/Users/diamond.hung/.claude/get-shit-done/workflows/execute-plan.md
@/Users/diamond.hung/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create lib/types.ts with CuisineType, Restaurant interface, and CUISINE_META</name>
  <files>lib/types.ts</files>
  <action>
    Create `lib/types.ts` with the following exact content. Do not deviate from this pattern — the `as const satisfies Record<>` combination is specifically chosen to (1) preserve literal key types for the union and (2) validate entry shape at compile time.

    ```typescript
    // lib/types.ts
    // Single source of truth for all type definitions and cuisine constants.
    // Pattern: as const satisfies Record<> derives union type from object keys
    // while validating each entry's shape at compile time.

    export const CUISINE_META = {
      chi:  { label: '中式', color: '#67C23A' },
      jp:   { label: '日式', color: '#E6A23C' },
      kr:   { label: '韓式', color: '#F56C6C' },
      tai:  { label: '泰式', color: '#909399' },
      west: { label: '西式', color: '#109399' },
    } as const satisfies Record<string, { label: string; color: string }>

    // CuisineType is inferred as: 'chi' | 'jp' | 'kr' | 'tai' | 'west'
    // This union is derived from CUISINE_META keys — adding a new cuisine here
    // automatically expands the type, and forgetting to add a color/label causes
    // a TypeScript error at the definition site, not at the usage site.
    export type CuisineType = keyof typeof CUISINE_META

    export interface Restaurant {
      id: string
      name: string
      type: CuisineType   // enforced as union — 'chinese' would be a compile error
      price: number       // TWD, integer — explicit number fixes the old Vue 2 string coercion bug
      distance: number    // meters, integer
    }
    ```

    Do NOT define cuisine labels or colors anywhere else. Any future component needing a label uses `CUISINE_META[restaurant.type].label`. Any component needing a color uses `CUISINE_META[restaurant.type].color`.
  </action>
  <verify>
    Run: `npx tsc --noEmit` in /Users/diamond.hung/ailabs/code/what-lunch

    Expected: No TypeScript errors in lib/types.ts. If strict mode catches any issue in the scaffold files (not in lib/types.ts), fix those too.

    Also verify file structure:
    - `CUISINE_META` has exactly 5 keys: chi, jp, kr, tai, west
    - `CuisineType` is derived via `keyof typeof CUISINE_META`
    - `Restaurant.price` and `Restaurant.distance` are typed as `number` (not string)
  </verify>
  <done>
    - `lib/types.ts` exists with CUISINE_META, CuisineType, and Restaurant interface
    - `npx tsc --noEmit` passes with no errors in lib/types.ts
    - CUISINE_META has 5 cuisine entries with label and color fields
    - Restaurant interface has id (string), name (string), type (CuisineType), price (number), distance (number)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create lib/restaurants.ts with all 19 default Taipei restaurants</name>
  <files>lib/restaurants.ts</files>
  <action>
    Create `lib/restaurants.ts` with the following exact content. Use `satisfies Restaurant[]` (not `: Restaurant[]`) — this validates each entry against the interface while preserving literal type narrowing. TypeScript will error if any `type` value is not a valid CuisineType, or if `price`/`distance` are strings.

    ```typescript
    // lib/restaurants.ts
    // Default restaurant data for the What Lunch app.
    // 19 Taipei restaurants migrated from the old Vue 2 dishes.json.
    //
    // Use `satisfies Restaurant[]` (not `: Restaurant[]`) to:
    // - Validate each entry's shape at compile time
    // - Preserve literal type narrowing (type stays 'chi' not 'string')
    // - Catch string-typed price/distance values (the old Vue 2 bug)

    import type { Restaurant } from './types'

    export const DEFAULT_RESTAURANTS = [
      { id: 'id-1',  name: '鼎泰豐',   type: 'chi',  price: 120, distance: 150 },
      { id: 'id-2',  name: '一蘭拉麵', type: 'jp',   price: 100, distance: 150 },
      { id: 'id-3',  name: '西提',     type: 'west', price: 160, distance: 250 },
      { id: 'id-4',  name: '韓國郎',   type: 'kr',   price: 115, distance: 150 },
      { id: 'id-5',  name: 'Sukiya',   type: 'jp',   price: 100, distance: 50  },
      { id: 'id-6',  name: '王品',     type: 'west', price: 120, distance: 400 },
      { id: 'id-7',  name: '瓦城',     type: 'tai',  price: 85,  distance: 110 },
      { id: 'id-8',  name: '吉野家',   type: 'jp',   price: 70,  distance: 310 },
      { id: 'id-9',  name: '我家牛排', type: 'west', price: 105, distance: 90  },
      { id: 'id-10', name: '小食泰',   type: 'tai',  price: 65,  distance: 850 },
      { id: 'id-11', name: '迴轉壽司', type: 'jp',   price: 70,  distance: 240 },
      { id: 'id-12', name: '夏慕尼',   type: 'west', price: 130, distance: 150 },
      { id: 'id-13', name: '打拋專賣', type: 'tai',  price: 150, distance: 510 },
      { id: 'id-14', name: '日式燒肉', type: 'jp',   price: 125, distance: 190 },
      { id: 'id-15', name: '義麵屋',   type: 'west', price: 145, distance: 380 },
      { id: 'id-16', name: '湄南小鎮', type: 'tai',  price: 105, distance: 110 },
      { id: 'id-17', name: '丼飯',     type: 'jp',   price: 100, distance: 10  },
      { id: 'id-18', name: '漢堡王',   type: 'west', price: 110, distance: 150 },
      { id: 'id-19', name: '熱炒100',  type: 'chi',  price: 90,  distance: 290 },
    ] satisfies Restaurant[]
    ```

    Verify the count is exactly 19 entries (id-1 through id-19). These are migrated from the old `src/store/dishes.json` in the Vue 2 codebase — do not add or remove entries.
  </action>
  <verify>
    Run: `npx tsc --noEmit` in /Users/diamond.hung/ailabs/code/what-lunch

    Expected: No TypeScript errors. The `satisfies Restaurant[]` annotation should validate all entries silently.

    Count check: `grep -c "id-" lib/restaurants.ts` should return 19.
  </verify>
  <done>
    - `lib/restaurants.ts` exists with DEFAULT_RESTAURANTS constant
    - Exactly 19 restaurant entries (id-1 through id-19)
    - All entries use valid CuisineType values (chi, jp, kr, tai, west)
    - All price and distance values are numbers (not strings)
    - `npx tsc --noEmit` passes
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire app/page.tsx to import DEFAULT_RESTAURANTS and verify full build</name>
  <files>app/page.tsx</files>
  <action>
    Update `app/page.tsx` to import from `lib/restaurants.ts` and display the restaurant count. This proves the import chain works and the build is fully type-safe end-to-end.

    ```typescript
    // app/page.tsx
    import { DEFAULT_RESTAURANTS } from '@/lib/restaurants'

    export default function HomePage() {
      return (
        <main className="p-8">
          <h1 className="text-2xl font-bold">What Lunch?</h1>
          <p className="text-muted-foreground mt-2">
            {DEFAULT_RESTAURANTS.length} restaurants available
          </p>
        </main>
      )
    }
    ```

    This is a Server Component (no 'use client' needed — no interactivity, just rendering).

    After writing the file, run the full production build:
    ```bash
    npm run build
    ```

    If the build fails, read the TypeScript error messages carefully:
    - Errors in `lib/types.ts` or `lib/restaurants.ts`: Fix the type definitions
    - Errors in scaffold files (app/layout.tsx, etc.): Fix those files to satisfy strict mode
    - Do NOT disable strict mode or add `// @ts-ignore` to fix errors

    Note: `npm run lint` is separate from `npm run build` in Next.js 16 — lint errors will not cause build failure.
  </action>
  <verify>
    1. `npm run build` exits 0 (no errors, no TypeScript failures)
    2. `grep "DEFAULT_RESTAURANTS" app/page.tsx` confirms the import is present
    3. Build output shows `app/page.tsx` compiled successfully
  </verify>
  <done>
    - `app/page.tsx` imports DEFAULT_RESTAURANTS from @/lib/restaurants
    - `npm run build` exits 0 with no TypeScript errors
    - Phase 1 success criteria are all met:
      1. `npm run build` completes with no TypeScript errors
      2. Restaurant interface and CuisineType exist in lib/types.ts and are importable
      3. Cuisine labels and colors are defined once only in CUISINE_META
      4. All 19 default restaurants are in DEFAULT_RESTAURANTS in lib/restaurants.ts
  </done>
</task>

</tasks>

<verification>
After all three tasks:
1. `npm run build` exits 0 — no TypeScript errors
2. `cat lib/types.ts | grep "CuisineType"` confirms the type exists
3. `grep -c "id-" lib/restaurants.ts` returns 19
4. `grep "DEFAULT_RESTAURANTS" app/page.tsx` confirms wiring
5. `grep "CUISINE_META" lib/types.ts` confirms cuisine constants exist
6. No other file in the codebase defines cuisine labels or colors (no duplicates)
</verification>

<success_criteria>
All Phase 1 success criteria met:
1. `npm run build` completes with no TypeScript errors
2. `Restaurant` interface and `CuisineType` union exist in `lib/types.ts` and are importable by any component
3. Cuisine type labels and colors are defined once and only once in `CUISINE_META` — no duplicate string literals across files
4. All 19 default restaurants are available as `DEFAULT_RESTAURANTS` typed constant importable from `lib/restaurants.ts`
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
